Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You must write an algorithm with O(log n) runtime complexity.

Example 1:

Input: nums = [1,3,5,6], target = 5
Output: 2

Example 2:

Input: nums = [1,3,5,6], target = 2
Output: 1


class Solution 
{
    public int searchInsert(int[] nums, int target) 
    {
        int left = 0;                    // Start of the searchable range
        int right = nums.length - 1;     // End of the searchable range

        while(left <= right)            // Continue searching while the search space is valid
        {
            // Calculate the middle index. 
            // Using 'left + (right - left) / 2' prevents integer overflow 
            // which can occur with '(left + right) / 2' in large arrays.

            int mid = left + (right - left)/2;

            if(nums[mid]==target)          // Check if the middle element is our target
            {
                return mid;
            }
            else if (nums[mid] < target)    // If the target is larger, search the right half
            {
                left = mid + 1;            // Discard the left half and 'mid' by moving 'left' past 'mid'
            }
            else if (nums[mid] > target)    // If the target is smaller, search the left half
            {
                right = mid - 1;          // Discard the right half and 'mid' by moving 'right' behind 'mid'
            }
        }
        return left;
    }
}
